\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{occi}
\setlength{\headheight}{13pt}
\pagestyle{fancy}

\newcommand{\doccode}{XXXXX}

% default sans-serif
\renewcommand{\familydefault}{\sfdefault}

% no lines for headers and footers
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

% header
\fancyhf{}
\lhead{\doccode}
\rhead{\today}

% footer
\lfoot{occi-wg@ogf.org}
\rfoot{\thepage}

% paragraphs need some space...
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

% some space between header and text...
\headsep 13pt

\setcounter{secnumdepth}{4}

\begin{document}

% header on first page is different
\thispagestyle{empty}

\doccode \hfill Augusto Ciuffoletti, Universit√† di Pisa\\ 
OCCI-WG\\
\rightline {September 22, 2014}\\
\rightline {Updated: \today}

\vspace*{0.5in}

\begin{Large}
\textbf{Open Cloud Computing Interface - Monitoring Extension}
\end{Large}

\vspace*{0.5in}
% My commands!

% This is for signed remarks
%\newcommand{\rem}[2]{\footnote{{\bf Remark by #1}: #2}}
\newcommand{\rem}[2]{}

\newcommand{\oc}[0]{\tt OCCI}
\newcommand{\mi}[0]{{\em mixin}}
\newcommand{\metr}[0]{{\em metric}}
\newcommand{\aggr}[0]{{\em aggregator}}
\newcommand{\publ}[0]{{\em publisher}}
\newcommand{\ent}[0]{{\em Entity}}
\newcommand{\rs}[0]{{\em Resource}}
\renewcommand{\ln}[0]{{\em Link}}
\newcommand{\sens}[0]{{\em Sensor}}
\newcommand{\comp}[0]{{\em Compute}}
\newcommand{\coll}[0]{{\em Collector}}

\underline{Status of this Document}
\input{include/status}

\underline{Copyright Notice}
Copyright \copyright ~Open Grid Forum (2009-2011). All Rights Reserved.

\underline{Trademarks}
OCCI is a trademark of the Open Grid Forum.

\underline{Abstract}
\input{include/abstract}

This document {\em defines} an OCCI Extension that allows the user to create a monitoring infrastructure for a cloud provision. The Monitoring Extension {\em introduces} two further entity types: the \sens\ Resource, that processes metrics, and the \coll\ Link, that extracts them.

\newpage
\tableofcontents
\newpage

\section{Introduction}

\input{include/introduction}

This document defines an {\em OCCI Extension} that provides the user with the an interface to create a monitoring infrastructure, with the aim of implementing relevant features like autonomic management, billing, and service level verification. The existence of an agreed interface enables the user to manage distinct cloud providers, possibly at the same time, in a uniform way.

The presence of a customized monitoring infrastructure is relevant in a wide range of scenarios, and the proposed interface is able to describe the many ways in which the monitoring results can be processed to obtain relevant metrics.

The communication of measurements inside and outside the monitoring infrastructure is another issue the framework must be flexible about. In fact, the amount of information that is produced by a measurement activity may range from negligible to ``big data'' dimensions, and the degree of confidentiality changes with the application scenario. The OCCI Monitoring Extension is sufficiently expressive to allow the user to describe the task, but leaves the provider the options to find a solution fitting the scale and the confidentiality terms of the problem.

One relevant fact about a monitoring infrastructure is that it is extremely difficult to give a {\em detailed} framework that extends its validity to any conceivable use case or provider. The reason is that the metrics that are used to evaluate the performance of the system are many, and subject to continuous changes due to the introduction of new technologies. The OCCI Monitoring Extension allows the user to describe the components a monitoring infrastructure, but does not interfere with details that may be transparently dealt with by the provider.

The applicability of the OCCI Monitoring Extension is not limited to the realm of computing infrastructures, since it is not bound to definite kinds of resources.

The OCCI Monitoring Extension defines two new entity types: the {\em Collector}, an OCCI-Link that defines the timing of the measurement process, and the {\em Sensor}, an OCCI-Resource that defines how the results of measurements are processed and used.

Using the OCCI-Monitoring API the user defines the frequency with which measurements are collected, as well as the time lapse during which the measurement process takes place. Such a {\em real-time} approach excludes those cases that envision an {\em event driven} notification of a state change: the OCCI-notification extension \ref{occi-notification} covers this case and is complementary to {\em OCCI monitoring}.

Whenever appropriate, further details of the monitoring activity can be specified through the association of provider-specific \mi s to a \sens\ or \coll\ instance: this allows the provider to address ``black box'' solutions, or to give the user the tools to customize one.

To classify the {\em mixin}s that define the operation of the {\em Sensor} and of the {\em Collector}, three tags, i.e. \mi s without attributes, are introduced: {\em Metric} to specify the production of measurement, {\em Aggregator} for their processing, and {\em Publisher} for their publication. Provider specific {\em Mixin}s are {\em related} to such tags, so to enforce a kind of subtyping. 

%The simplest case of a monitoring infrastructure consists of a single \coll\ that links a monitored resource to a \sens\ that publishes the raw metrics; it is illustrated in figure \ref{fig:onestage}.

%\begin{figure}
%\centering
%\includegraphics[width=0.5 \linewidth]{onestage.pdf}
%\caption{The simplest case: one \coll\ and one \sens\ \label{fig:onestage}}
%\end{figure}

The OCCI-Monitoring API is designed to scale from very simple use cases, that the user can define with minimal effort, to complex cases, like multilayer monitoring infrastructures. The same basic building blocks are used at any degree of complexity.

%The {\em Resource Management} box stands for a resource that is the end-user of the monitoring activity. It's {\em Kind} is bound to the publishing technique used in the \coll . It may be, for instance, a {\em Compute} resource that embeds a load balancing or accounting functionality, or a yet to define {\em Mailbox} resource where periodic reports are posted. 

\rem{author}{Why not a mixin to the monitored resource directly? I envision problems emerging with the implementation. A resource can be ``prepared'' for monitoring, but the way in which the Monitoring Link will interact with such preparation is not clear. In addition, consider that the same tool might be the target of several links, with distinct configuration parameter. How can the control parameters of the mixin be exposed in such a case? Instead, if the mixin is embedded in the link, it is the responsibility of the link implementation to configure it, and to couple it with the publishing technology indicated in the link}

\begin{figure}
\centering
\includegraphics[width=0.3\textwidth]{figs/Monitoring_UML.pdf}
\caption{Class inheritance diagram for OCCI-monitoring}
\end{figure}

\section{Specification of the server that provides OCCI Monitoring}

The compliant server MUST implement the {\em kind}s in table \ref{tab:kinds}, and the {\em mixin}s in table \ref{tab:mixin}.

\mytablefloat{
        \label{tab:kinds}The immutable model attributes of the \sens\ and of the \coll\ kinds.
        The base URL {\bf http://schemas.ogf.org/occi} has been replaced with
        {\bf $<$schema$>$} in this table for a better readability experience. 
        } {
        \begin{tabular}{llllll}
        \toprule
        Term & Scheme & Title & Attributes & Actions & Parent\\
        \colrule
        sensor &  $<$schema$>$/monitoring\# & Sensor Resource
        & see Table \ref{tab:sensor} & \{\} &  $<$schema$>$/core\#resource\\
        collector &  $<$schema$>$/monitoring\# & Collector Link
        & see Table \ref{tab:collector} & \{\} & $<$schema$>$/core\#link \\
        \botrule
        \end{tabular}
}

The attributes of the two kinds are illustrated in section \ref{sec:sensor} and in section \ref{sec:collector} respectively.

The mixins have no capabilities: they are used as tags for other mixins with given features, as described in section \ref{sec:metric}, \ref{sec:aggregator}, \ref{sec:publisher}.


\mytablefloat{
        \label{tab:mixin}The immutable model attributes of the {\em Metric}, {\em Aggregator} and {\em Publisher} mixins.
        The base URL {\bf http://schemas.ogf.org/occi} has been replaced with
        {\bf $<$schema$>$} in this table for a better reading experience. 
        } {
        \begin{tabular}{lllllll}
        \toprule
        Term & Scheme & Title & Attributes & Actions & Depends & Applies \\
        \colrule
        metric &  $<$schema$>$/monitoring\# & Metric Mixin 
        & \{\} & \{\} & \{\} & $<$schema$>$/monitoring\#collector \\
        aggregator &  $<$schema$>$/monitoring\# & Aggregator Mixin 
        & \{\} & \{\} & \{\} & $<$schema$>$/monitoring\#sensor \\
        publisher &  $<$schema$>$/monitoring\# & Publisher Mixin 
        & \{\} & \{\} & \{\} & $<$schema$>$/monitoring\#sensor \\
        \botrule
        \end{tabular}
}
\subsection{The \sens\ resource \label{sec:sensor}}

\mytablefloat{
        \label{tab:sensor} 
        \hl{Attribute}s of the Sensor resource.
}{
\begin{tabular}{lp{1.5cm}p{1cm}lp{5.5cm}}
\toprule
Attribute&Type&Multi\-plicity&Mutability&Description\\
\colrule
occi.sensor.timebase & string & 0..1 & true & Base time reference (ISO8601) \\  
occi.sensor.timestart &	number & 0..1 & true & Start time offset (seconds) \\
occi.sensor.timestop & number	& 0..1 & true & Stop time offset (seconds) \\
occi.sensor.period & number & 1 & true & Time between two following measurements (seconds) \\
occi.sensor.granularity & number & 0..1 & true & Granularity of time measument (seconds) \\
occi.sensor.accuracy & number & 0..1 & true & Accuracy of time measument (seconds) \\
\botrule
\end{tabular}
}

The {\em kind} instance assigned to the \sens\ type is {\tt http://schemas.ogf.org/occi/monitoring\#sensor}, as in table \ref{tab:kinds}. The attributes of the \sens\ (see table \ref{tab:sensor}) describe the real-time properties of the sequence of metric values: the time interval during which the monitoring activity is in effect, and its frequency.

The start of the monitoring activity is determined as the sum between a reference date and time ({\tt timebase}) and an offset ({\tt timestart}). Another offset determines the time when the monitoring activity terminates ({\tt timestop}). The attributes may be left undefined, to indicate that the monitoring activity persists for the lifetime of the sensor. A negative {\tt timebase} indicates that the monitoring activity is suspended. The three attributes can be modified by the user to dynamically control the monitoring activity.

The frequency of the monitoring operation is controlled by a value that corresponds to the time lapse between successive samples ({\tt period}). This attribute is required.

The precision of the time scale is defined by two attributes, the {\tt granularity} and the {\tt accuracy}. The former represents the minimum distance in time between two following time values, the latter indicates the maximum distance between the measured time and the real time. These attributes may be left unspecified.

The server SHOULD respond with an error, without allocating the \sens\ resource, when the period of operation is partially in the past, or when the stop time precedes the start time. The server SHOULD NOT respond with an error when the {\tt period}, the {\tt granularity} or the {\tt accuracy} cannot be met. Instead, it SHOULD attempt a {\em best fit} of the requested values, setting the appropriate values for the attributes. The server SHOULD fill undefined {\tt granularity} or the {\tt accuracy} attributes with worst case values. 

\subsection{The \coll\ link \label{sec:collector}}

\mytablefloat{
        \label{tab:collector}%
        \hl{Attribute}s of the Collector link.
}{
\begin{tabular}{lp{1.5cm}p{1cm}lp{5.5cm}}
\toprule
Attribute&Type&Multi\-plicity&Mutability&Description\\
\colrule
occi.collector.period & number & 1 & true & Time between two following measurements (seconds) \\
occi.collector.granularity & number & 0..1 & true & Granularity of time measument (seconds) \\
occi.collector.accuracy & number & 0..1 & true & Accuracy of time measument (second\\
\botrule
\end{tabular}
}

The {\em kind} instance assigned to the \coll\ type is {\tt http://schemas.ogf.org/occi/monitoring\#collector}, as in table \ref{tab:kinds}. The attributes of the \coll\ (see table \ref{tab:collector}) model the activity that extracts measurements from a destination {\em resource} and the transfer of such measurements to a source \sens. The {\em source} of a \coll\ MUST be a \sens: the server MUST respond with an error to the request of instantiation of a \coll\ if the source is not a \sens.

The OCCI attributes of the \coll\ define the timing of the monitoring activity.
The execution rate is defined using three attributes: the rate itself (\verb|period|), and the quality of the timing ({\tt granularity} and {\tt timing}). All three values can be left unspecified.

The server SHOULD NOT respond with an error when the {\tt period}, the {\tt granularity} or the {\tt accuracy} cannot be met. Instead, it SHOULD attempt a {\em best fit} of the requested values, setting the appropriate values for the attributes. The server SHOULD fill undefined {\tt granularity} or {\tt accuracy} attributes with worst case values. 

\subsection{Features of the \mi s that depend on the {\em Metric} tag \label{sec:metric}}

The {\em mixin} instance assigned to the {\em metric} mixin is {\tt http://schemas.ogf.org/occi/monitoring\#metric}, as in table \ref{tab:mixin}. The {\em metric} mixin has no capabilities, and is used as a tag for mixins that customize a \coll\ link, by specifing the collected metrics and the measurement process.

The OCCI attributes of a {\em mixin} that depends on the {\em metric} tag are divided into two groups:
\begin{itemize}

\item Metric attributes: they represent the delivered measurements. They are {\em String} identifiers that are associated with {\em output channel}s (see section \ref{sec:channel});
\item Control attributes: they control the operation of the measurement activity.
\end{itemize}

\subsection{Features of the \mi s that depend on the {\em Aggregator} tag \label{sec:aggregator}}

The {\em mixin} instance assigned to the {\em aggregator} mixin is {\tt http://schemas.ogf.org/occi/monitoring\#aggregator}, as in table \ref{tab:mixin}. The {\em aggregator} mixin has no capabilities, and is used as a tag for mixins that customize a \sens\ resource, by specifing how raw metrics are processed before being published.

The OCCI attributes of a \mi\ that depends on the {\em aggregator} tag are divided into three groups:

\begin{itemize}
\item Input attributes: they bind an input of the aggregating algorithm with the metrics coming from monitored resources connected with outgoing \coll s. They are {\em String} identifiers that are associated with {\em input channel}s (see section \ref{sec:channel});
\item Control attributes: they control the operation of the aggregating function;
\item Metric attributes: they represent the delivered measurements. They are {\em String} identifiers that are associated with {\em output channel}s (see section \ref{sec:channel}).
\end{itemize}

\subsection{Features of the \mi s that depend on the {\em Publisher} tag \label{sec:publisher}}

The {\em mixin} instance assigned to the {\em publisher} mixin is {\tt http://schemas.ogf.org/occi/monitoring\#publisher}, as in table \ref{tab:mixin}. The {\em publisher} mixin has no capabilities, and is used as a tag for mixins that customize a \sens\ resource, by specifing how metrics are published.

The OCCI attributes of a \mi\ that depends on the {\em publisher} tag are divided into two groups:

\begin{itemize}
\item Input attributes: they bind the publishing process with the metrics produced by metric or aggregator mixins. They are {\em String} identifiers that are associated with an {\em input channel} (see section \ref{sec:channel});
\item Control attributes: they control the process used to publish input attributes.
\end{itemize}

\subsection{The scope and the monitoring pipe \label{sec:channel}}

The three types of mixins --- namely, {\em metric}, {\em aggregator}, and {\em publisher} --- are meant to represent the three stages of a pipe. Measurements flow across the three stages, from the monitored resource to the point where they are published. The provider has control on the monitoring infrastructure the user is able create, since this ultimately depend on the available {\em mixin}s of the above types.

In case the provider allows the user to compose the building blocks, instead of offering only pre-configured monitoring schemas, the API must be powerful enough to define the flow of data between the building blocks. Input and output {\em channel} attributes fit the purpose: when they share the same value (or {\em channel} identifier), the measurements flow from input ones to output ones.

The visibility or {\em scope} of {\em channel} identifiers is limited within a \sens\ and its outgoing \coll.

According with the core properties of {\em resources} and {\em links} (see \cite{occi:core}), the removal of a \sens\ determines the removal of all \coll s in its {\em scope}.

\section{Conformance profiles}

The definition of conformance profiles is appropriate because the provision of an extension is optional, so it is appropriate to define a conformant behavior when the extension is not implemented, or when it is implemented at a lesser degree. 

\begin{description}

\item[Profile 0] The \coll\ and \sens\ {\em Kind} s MUST NOT be implemented: attempt of instantiating entities of such {\em Kinds} fails. The {\em Aggregator}, {\em Metric}, and {\em Publisher} \mi s MUST NOT be implemented: their discovery fails;

\item[Profile 1] The \coll\ and \sens\ {\em Kind} s MUST be implemented, and the user MUST be allowed to create new instances of such {\em Kinds}. The {\em Aggregator}, {\em Metric}, and {\em Publisher} \mi\ MUST be implemented, and discovery is successful. The server MUST NOT allow to introduce {\em depends} relationships with the {\em Aggregator}, {\em Metric}, and {\em Publisher} \mi s; 

\item[Profile 2]  The \coll\ and \sens\ {\em Kind} s MUST be implemented, and the user MUST be allowed to create new instances of such {\em Kinds}. The \aggr , \metr , and \publ\ \mi s MUST be implemented, and discovery is successful. The user MUST be allowed to introduce {\em depends} relationships with  {\em Aggregator}, {\em Metric}, and {\em Publisher} \mi s.

\end{description}

\rem{
\section{Related works}

The topic of Cloud Service Level Agreement has been extensively studied in a number of research projects, and there are results that have an impact on Cloud Monitoring: a report \cite{EU-SLA} of the European Union illustrates the results in the field. We have taken input from this activity in the design of this API.

In particular, we considered the need of taking into account the presence of {\em composite services} encompassing several providers for their implementation. Tightly related ot this is the need of representing multilevel monitoring infrastructures, a fact anticipated by the results of the SLA@SOI EU project. The results of the {\em Stream} project highlight how monitoring data may introduce {\em big data} issues, that need specific, flexible solutions on the provider's side: this is one of the reasons that induced the introduction of opaque {\em connectors} that hide sophisticated, rapidly evolving technologies. The IRMOS project puts an accent on timing requirements for multimedia services, that justify the attention we paid to define and qualify timing attributes. Many project made precise statements about the specific metrics that describe the Service Level for specific types of resource: the mPlane project addresses specifically the metrics for Network resources, while Cloud4SOA focusses on the relevance of an agreed set of standard metrics.

In the design of this API we also took advantage of the experience gained during the CoreGRID EU-project \cite{cur:08:a}, where we implemented a Grid monitoring infrastructure, in its turn inspired by many previous works (see the bibliography in the paper).

The reading of the CompatibleOne prototype \cite{mar12a} is an Open Source project aimed at developing an OCCI-compliant Cloud Infrastructure: its interface, that already covers monitoring and SLA aspects, helped with a concrete view of a possibile interface. It has been enlightening concerning (among the rest) the need and possibility of modularizing the monitoring part.

The 2012 revision of the OCCI core model \cite{occi:core} has been used as a reference.

}

\section{Security issues}
The OCCI Notification specification is an extension to the OCCI Core
and Model specification \cite{occi:core}; thus the same security
considerations as for the OCCI Core and Model specification apply
here.

\rem{\label{s:security}

The API described in this document relies on the same mechanism as the basic OCCI API, of which it is an extension. In its turn, the OCCI API is designed according with a RESTFul model, a style of exposing a web service to the users.

The way this API is exposed inherits the security aspects of the RESTFul model, that can be summarized as follows:

\begin{itemize}
\item the web site MUST be protected to allow access only to authorized users, and to protect the content of the communication;
\item the content uploaded on the web site by the user (using POST) MUST be protected;
\item the content cached on third party sites not directly accessible by the user and by the provider (proxies etc.) MUST be protected.
\end{itemize}

We stress that these security warnings are shared with any ReStFul API.

The provider must ensure that a user defined \mi\ does not compromise the security of other services. The provider may attain this by restricting the functionalities associated to a \mi\ (the limit case is the provision of templates) or run the functionalities associated to a \mi\ in a protected environment (e.g., as a Unix user in a chroot jail). This issue is shared with the OCCI model.

Concerning the kind of monitoring infrastructure deployed using the \sens\ and the \coll , security aspects are managed using appropriate \mi s. For instance the \coll\ might be associated with a \mi\ describing a secure transport protocol, while the sensor might be configured to be accessible only from authenticated users (?). The provider SHOULD offer the user a set of predefined \mi s that introduce the appropriate level of security. User defined \mi s SHOULD be avoided for this kind of options.
}

\section{Glossary}
\label{sec:glossary}
\input{include/glossary}
 
\section{Contributors}

\textbf{Augusto Ciuffoletti (corresponding author)} \\
Dept. of Computer Science \\
L.go B. Pontecorvo - Pisa\\
Italy \\
Email: augusto.ciuffoletti@gmail.com \\

\textbf{Andrew Edmonds}\\
Institute of Information Technology \\
Z√ºrich University of Applied Sciences \\
Z√ºrich \\
Switzerland \\
Email: andrew.edmonds@zhaw.ch

\textbf{Metsch, Thijs} \\
Intel Ireland Limited \\
Collinstown Industrial Park \\
Leixlip, County Kildare, Ireland
Email: thijsx.metsch@intel.com

\textbf{Ralf Nyren} \\
Email: ralf@nyren.net 


\section{Intellectual Property Statement}
\input{include/ip}

\section{Disclaimer}
\input{include/disclaimer}

\section{Full Copyright Notice}
\input{include/copyright}



%\section{Acknowledgments}

%Include if desired. Contributors to the document may also be listed in the previous section.

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
\appendix

\section*{Appendix - Examples: from simple to complex}

The OCCI Monitoring API is able to meet the demands of a wide range of users. It is understood that an application that has a limited interest in monitoring (for instance to trigger human intervention to cope with a fault) wants an interface able to configure in a straightforward way a simple strategy. In contrast, the user that is faced with a complex infrastructure and tight quality requirements needs an expressive interface. On the provider side as well there is interest for the possibility of restricting the monitoring tools available to certain users to a restricted set, with limited capabilities. The challenge for the overall scheme is to cover the whole range, from simple to complex.

In this appendix we explore use cases starting from a very simple one, approached in a simplistic way. The involved {\em Entities} are described by listing their attributes; both model attributes, in bold, and OCCI attributes. We recall that model attributes are not discoverable by the client, while OCCI attributes are.

\subsection*{Case 1: too simple}

We start from an extremely simple case, that the user wants to implement trading off efficiency for simplicity. We focus on the {\tt iostat} \mi\ used above, that a user wants to use to be warned about the overload of a server {\tt \small vm1}.

The simplistic, yet suboptimal, solution is to associate the server with the monitoring tool. At a certain point in time, when the cpuutilization is $78\%$, the state of a certain server might be the following:

{
\small
\begin{tabular}{l|l}
Attribute                         & value \\ \hline
{\bf id}                          & urn:acme:user529/vm1 \\
{\bf kind}                        & compute \\
{\bf mixin}                       & iostat-here \\
occi.compute.architecture         & x86   \\
occi.compute.cores                & 4     \\ 
occi.compute.hostname             & vm1   \\            
occi.compute.speed                & 3     \\                  
occi.compute.memory               & 250   \\
com.acme.iostat.cpuutilization    & 78    \\                     
com.acme.iostat.what              & user  \\
\end{tabular}
}

The provider declares to update the {\em metric} attribute {\tt \small cpuutilization} every 10 minutes, and the user is happy with that latency. From time to time the user will download the REST resource associated with the {\em Compute Resource} and parse out the value of the attribute, that will be processed in user's premises.

Let's consider a possible implementation on provider's side. Whenever the user associates the {\tt \small iostat} mixin to the {\em Compute Resource}, the Cloud Management Infrastructure will install and launch a script that performs the call to the {\tt \small iostat} command, and then sends the data to the Cloud Management Interface. In its turn, the Cloud Management server will update the record describing the Compute Resource. At this time any cached content of the same record should become invalid.

It is a quite complex operation that hardly fits in a REST environment.

This solution, which is admissible for our API, is extremely simple for the user, but extremely inefficient and complex for the provider. Let us explore an slightly more complex alternative that exhibits a reasonable footprint.

\subsection*{Case 2: simple but effective}

The user, in addition to the \metr\ \mi , associates to {\tt \small vm1} also a \publ\ \mi : for instance a {\tt \small tcp} mixin. Its semantic is that the data is returned after a {\tt \small connect} to a given TCP address, that we assume to be located on the same virtual machine.

{
\small
\begin{tabular}{l|l}
Attribute                         & value \\ \hline
{\bf id}                          & urn:acme:user529/vm1 \\
{\bf kind}                        & compute \\
{\bf mixin}                       & iostat, tcp \\
occi.compute.architecture         & x86   \\
occi.compute.cores                & 4     \\ 
occi.compute.hostname             & vm1   \\            
occi.compute.speed                & 3     \\                  
occi.compute.memory               & 250   \\
com.acme.iostat.cpuutilization    & cpustat   \\                     
com.acme.iostat.what              & user  \\
com.acme.tcp.in                   & cpustat \\
com.acme.tcp.source               & http://www.acme.com/user529-vm1 \\
com.acme.tcp.port                 & 4321 \\
\end{tabular}
}

The provider declares that the latency of the data is less than 10 minutes. The user will poll the socket from time to time, and obtain the CPU utilization.

Let's consider a possible implementation on the provider's side. Upon association of the two \mi , the Cloud Management server will trigger the {\tt \small iostat} script, and implement a pipe to trasfer the results to a TCP server listening on the indicated port. The configuration of the pipe is driven by the correspondence between the string ({\tt cpustat}) associated with the {\em metric attribute} of the {\tt \small iostat} \mi , and the {\em input attribute} of the {\tt \small tcp} \mi .

In a similar way, not shown in this example, the user may associate also an \aggr\ \mi\ to {\tt \small vm1} to process the raw measurements and obtain a filtered metric.

Note that the activity of the Cloud Management server is limited to the configuration of the two {\em mixins}. After that, the record of {\tt \small vm1} will be updated with the presence of the two \mi s. There is no further activity on the side of the provider, and caches will remain consistent after that operation.

\subsection*{Widening the horizon}

Consider that the user has allocated a pool of servers {\tt \small vm1...vmn} and that she needs only the maximum CPU utilization in the pool. Instead of downloading all measurements and find the maximum in her premises, she prefers to delegate the task to the Cloud Management.

Our solution is to create one \coll\ instance in egress from each server, and to associate a {\tt \small iostat} \mi\ to each of them, thus adding the possibility to control the timing of the measurements. There will be one addressable REST resource for each of them.

All the \coll\ instances will share the same destination, that might be one of the servers. There an \aggr\ \mi\ aggregates the data by computing the maximum each time a new value is received, and delivers the data to the TCP server described in the previous example. The following is the state of one of the collectors:

{
\small
\begin{tabular}{l|l}
Attribute                         & value \\ \hline
{\bf id}                          & urn:acme:user529/c1 \\
{\bf kind}                        & collector \\
{\bf mixin}                       & iostat \\
{\bf source}                      & urn:acme:user529/vm1 \\
{\bf target}                      & urn:acme:user529/master \\
occi.collector.period             & 600 \\
com.acme.iostat.cpuutilization    & cpustat1 \\                     
com.acme.iostat.what              & user \\
\end{tabular}
}

and this is the state of the master server that receives all measurements, computes the output value and delivers the result throufh a TCP socket:

{
\small
\begin{tabular}{l|l}
Attribute                     & value \\ \hline
{\bf id}                      & urn:acme:user529/master \\
{\bf kind}                    & compute \\
{\bf mixin}                   & max, tcp \\
{\bf links}                   & 
\begin{tabular}{l}
urn:acme:user529/c1, \\
urn:acme:user529/c2, \\
urn:acme:user529/c3 
\end{tabular} \\
occi.compute.architecture     & x86   \\
occi.compute.cores            & 4     \\ 
occi.compute.hostname         & master   \\            
occi.compute.speed            & 3     \\                  
occi.compute.memory           & 250   \\
com.acme.tcp.in               & cpumax \\
com.acme.tcp.source           & http://www.acme.com/user529/master \\
com.acme.tcp.port             & 4321 \\
com.acme.max.data             & cpustat1, cpustat2, cpustat3 \\
com.acme.max.max              & cpumax  \\
\end{tabular}
}

The use of \coll\ has a number of advantages, that are all related with the fact that the activities associated with the \mi\ obtain a distinguished address in the system, and thus are REST resources on their own. For instance, multiple instances of the same monitoring tool may run on the same \rs .

\subsection*{Separation of concern}

In the above example the measurements are processed on a generic computing resource: however, there are cases when monitoring data deserve a specific treatment, that can be hardly implemented inside a generic virtual machine. For instance when it has an heavy footprint, or it requires accurate timing, or it has effects that cannot be triggered by a generic virtual machine, or it is considered as confidential. If this is the case, then it is time to create an instance of a \sens .

For our example, we consider a user that wants to put in place a mechanism that instantiates a new server as soon as the maximum {\tt \small cpuutilization} on one of the servers reaches a given threshold. For reasons related with system integrity, the provider does not allow to associate this activity to a generic \rs , but it implements this privileged operation in a \publ\ \mi\ that can be associated only with a \sens . The \mi\ that manages the generation of the new request is called {\em elasticpool}: for simplicity, we assume that it exposes a single attribute, the threshold, in the interval $[0..1]$, but we may imagine that a realistic \mi\ may indicate a template for the new resource, a {\em Collection} where to include the resource, and a deallocation rule.

The layout of the system is now made of a number of \coll , one for each server in the pool, and one sensor that aggregates all results and allocates new \comp\ when needed.

Each of the collectors will be defined as follows:

{
\small
\begin{tabular}{l|l}
Attribute                         & value \\ \hline
{\bf id}                          & urn:acme:user529/c1 \\
{\bf kind}                        & collector \\
{\bf mixin}                       & iostat    \\
{\bf source}                      & urn:acme:user529/vm1 \\
{\bf target}                      & urn:acme:user529/s1  \\
occi.collector.period             & 600   \\
com.acme.iostat.cpuutilization    & cpustat1   \\                     
com.acme.iostat.what              & user  \\
\end{tabular}
}

The \sens\ state is the following :


{
\small
\begin{tabular}{l|l}
Attribute                     & value \\ \hline
{\bf id}                      & urn:acme:user529/s1 \\
{\bf kind}                    & sensor \\
{\bf mixin}                   & max, tcp \\
{\bf links}                   & 
\begin{tabular}{l}
urn:acme:user529/c1, \\
urn:acme:user529/c2, \\
urn:acme:user529/c3 
\end{tabular} \\
occi.sensor.period            & 600 \\
occi.sensor.timebase          & 1371025907 \\  
occi.sensor.timestart         & 10 \\
occi.sensor.timestop          & 3610 \\
com.acme.tcp.in            & maxcpu \\
com.acme.tcp.source        & http://www.acme.com/user529/master \\
com.acme.tcp.port          & 4321 \\
com.acme.max.data          & cpustat1, cpustat2, cpustat3 \\
com.acme.max.max           & maxcpu  \\
\end{tabular}
}


\input{sla.tex}


\input{legal}


% \phantomsection\addcontentsline{toc}{section}{References}
\section{References}

% Define heading of bibliography to be empty, since we already have a heading above the text.
\renewcommand{\refname}{}
\vspace*{-3em}

% Use bibliography.bib for references.
\bibliography{biblio,cur}

% Alternatively, you can insert the bibliography inline, like so:
% 
% \begin{thebibliography}{5}
% 
% \bibitem[GFD0000()]{gfd0000}
% Firstname Author1 and Firstname Author2.
% \newblock {Our Awesome Grid Forum Document}.
% \newblock GWD-C.0000, April 2002.
% 
% \bibitem[GFD152()Catlett, de~Laat, Martin, Newby, and Skow]{gfd152}
% Charlie Catlett, Cees de~Laat, David Martin, Gregory~B. Newby, and Dane Skow.
% \newblock {Open Grid Forum Document Process and Requirements}.
% \newblock GFD-C.152, June 2009.
% \newblock URL \url{http://www.ogf.org/documents/GFD.152.pdf}.
% 
% \bibitem[RFC2119()]{rfc2119}
% Scott Bradner.
% \newblock {Key words for use in RFCs to Indicate Requirement Levels}.
% \newblock RFC 2119 (Best Current Practice), March 1997.
% \newblock URL \url{http://tools.ietf.org/html/rfc2119}.
% 
% \bibitem[RFC3552()Rescorla, Korver, and {Internet Architectures Board}]{rfc3552}
% Eric Rescorla, Brian Korver, and {Internet Architectures Board}.
% \newblock {Guidelines for Writing RFC Text on Security Considerations}.
% \newblock RFC 3552 (Best Current Practice), July 2003.
% \newblock URL \url{http://tools.ietf.org/html/rfc3552}.
% 
% \bibitem[RFC3967()]{rfc3967}
% Randy Bush and Thomas Narten.
% \newblock {Clarifying when Standards Track Documents may Refer Normatively to Documents at a Lower Level}.
% \newblock RFC 3967 (Best Current Practice), December 2004.
% \newblock URL \url{http://tools.ietf.org/html/rfc3967}.
% 
% \end{thebibliography}



\end{document}
