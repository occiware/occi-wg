\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{occi}
\setlength{\headheight}{13pt}
\pagestyle{fancy}

% default sans-serif
\renewcommand{\familydefault}{\sfdefault}

% no lines for headers and footers
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

% header
\fancyhf{}
\lhead{GWD-R}
\rhead{\today}

% footer
\lfoot{occi-wg@ogf.org}
\rfoot{\thepage}

% paragraphs need some space...
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

% some space between header and text...
\headsep 13pt

\setcounter{secnumdepth}{4}

% comments, temp stuff
\newcommand{\ralf}[1]{\textcolor{red}{Ralf: #1}}

\begin{document}

% header on first page is different
\thispagestyle{empty}

GWD-R \hfill Thijs Metsch, Platform Computing\\
OCCI-WG \hfill Andy Edmonds, Intel\\
\rightline {October 7, 2010}\\
\rightline {Updated: \today}

\vspace*{0.5in}

\begin{Large}
\textbf{Open Cloud Computing Interface - RESTful HTTP Rendering}
\end{Large}

\vspace*{0.5in}

\underline{Status of this Document}

This document provides information to the community regarding the
specification of the Open Cloud Computing Interface. Distribution is
unlimited.

\underline{Copyright Notice}

Copyright \copyright Open Grid Forum (2009-2010). All Rights Reserved.

\underline{Trademarks}

OCCI is a trademark of the Open Grid Forum.

\underline{Abstract}

This document, part of a document series, produced by the OCCI working
group within the Open Grid Forum (OGF), provides a high-level
definition of a Protocol and API. The document is based upon
previously gathered requirements and focuses on the scope of important
capabilities required to support modern service offerings.

\newpage
\tableofcontents
\newpage

\section{Introduction}
\input{include/introduction}

\section{Notational Conventions}
\input{include/notational}

This document uses the Augmented Backus-Naur Form (ABNF) notation of RFC 2616
\cite{rfc2616}, and explicitly includes the following rules from it:
quoted-string, token, SP (space), LOALPHA, DIGIT.

All examples in this document use one of the following three HTTP
category definitions. An example name-space hierarchy is also
given. Syntax and Semantics is explained in the remaining sections of
the document. These examples do not strive to be complete but to show
the functionalities OCCI has:

\begin{verbatim}

Category: compute;
          class=kind;
          scheme=http://schemas.ogf.org/occi/infrastructure#;
          location=/compute 
    (This is an compute kind)

Category: storage;
          class=kind;
          scheme=http://schemas.ogf.org/occi/infrastructure#;
          location=/storage 
    (This is an storage kind)

Category: my_stuff;
          class=mixin;
          scheme=http://example.com/occi/my_stuff#;
          location=/my_stuff 
    (This is a mixin of user1)

The following namespace hierarchy is used in the examples:

http://example.com/-/
http://example.com/vms/user1/vm1
http://example.com/vms/user1/vm2
http://example.com/vms/user2/vm1
http://example.com/disks/user1/disk1
http://example.com/disks/user2/disk1
http://example.com/compute/
http://example.com/storage/
http://example.com/my_stuff/
\end{verbatim}

The following terms \cite{rfc3986} are used when referring to URI components:

\begin{verbatim}
 http://example.com:8080/over/there?action=stop#xyz
 \__/   \______________/\_________/ \_________/ \_/
  |           |            |            |        |
scheme     authority       path        query   fragment
\end{verbatim}

All examples in this document use the \emph{text/plain} HTTP
Content-Type for posting information. To retrieve information the HTTP
Accept header \emph{text/plain} is used.

This specification is aligned with RFC 3986 \cite{rfc3986}.

\section{OCCI HTTP Rendering}

The OCCI HTTP Rendering document specifies how the OCCI Core Model
\cite{occi:core}, including extensions thereof, is rendered over the HTTP
protocol \cite{rfc2616}. The document describes the general behavior for all
interaction with an OCCI implementation over HTTP together with three content
types to represent the data being transferred. The content types specified are
\textit{text/plain}, \textit{text/occi} and \textit{text/uri-list}. Other
data formats such as e.g.~OVF and JSON will be specified in complimentary
documents.

\subsection{A RESTful HTTP Rendering for OCCI}

The OCCI HTTP Rendering uses
all the features the HTTP and underlying protocols offer but also
builds upon the Resource Oriented Architecture (ROA). ROA's use
Representation State Transfer (REST) \cite{REST_Fielding} to cater for
client and service interactions. Interaction with the system is by
inspection and modification of a set of related resources and their
states, be it on the complete state or a sub-set. Resources MUST be
uniquely identified. HTTP is an ideal protocol to use in ROA systems
as it provides the means to uniquely identify individual resources
through URLs as well as operating upon them with a set of
general-purpose methods known as HTTP verbs. These HTTP verbs map
loosely to the resource related operations of Create (POST), Retrieve
(GET), Update (POST/PUT) and Delete (DELETE).

Each resource instance within an OCCI system MUST be uniquely identified by an
URI stored in the {\em id} attribute of the \hl{Entity} type
\cite{occi:core}.
%
The structure of these URIs is opaque and the system should not assume a
static, pre-determined scheme for their structure. For example
\emph{Entity::id} can be \emph{http://example.com/vms/user1/vm1}.

\subsection{Behaviour of the HTTP Verbs}
As OCCI adopts a ROA, REST-based architecture and uses HTTP as the
foundation protocol the means of interaction with all RESTful resource
instances is through the four main HTTP verbs. OCCI service
implementations MUST, at a minimum, support these verbs as shown in
table \ref{tbl:http_verbs}.

\mytablefloat{\label{tbl:http_verbs}HTTP Verb Behavior}{
\begin{tabular}{p{1in} p{0.7in} p{0.7in} p{0.7in} p{0.7in} p{0.7in} p{0.7in}}
\toprule
Type & GET & POST (create) & POST (action) & PUT (create) & PUT (update) & DELETE \\
\colrule
resource instance & 
Rendering of this resource instance & 
Create a new resource instance & 
Trigger action & 
Create an resource instance at the given path & 
Update an resource instance at an given path & 
Delete this resource instance \\
\colrule
Path in the name-space hierarchy ending with / &	
Listing of all resource instances below this name-space & 
Create a new resource instance & 
N/A & 
N/A & 
N/A & 
Delete all the resource instances below this name-space hierarchy \\
\colrule
Location of an \hl{Mixin} or \hl{Kind} & 
Listing containing locations to all resource instances belonging to this \hl{Mixin} or \hl{Kind} & 
N/A & 
Trigger action (defined for this kind or mixin) on all resource instances belonging to this \hl{Mixin} or \hl{Kind} & 
Add an resource instance to a \hl{Mixin} & 
N/A & 
Remove an resource instance given in the request from a \hl{Mixin} \\
\colrule
Query Interface	& 
Listing of all registered \hl{Kind}s and \hl{Mixin}s & 
N/A & 
N/A & 
Add a user defined \hl{Mixin} & 
N/A & 
Remove a user-defined \hl{Mixin} (defined in the request) \\
\botrule
\end{tabular}
}

\subsection{A RESTful Rendering of OCCI}
The following sections and paragraphs describe how the OCCI model MUST
be implemented by OCCI implementations. Operations which are not
defined are out of scope for this specification and MAY be implemented
. This is the minimal set to ensure interoperability.

\subsubsection{Name-space Hierarchy and Location}
The name-space and the hierarchy are free definable by the Service
Provider. The OCCI implementation needs to implement the location path
feature, which is required by OCCI for discovering capabilities and
operations on \hl{Mixin}s and \hl{Kind}s. Location paths tell the
client where all resource instance of one \hl{Kind} or \hl{Mixin} can
be found regardless of the hierarchy the service provider
defines. These paths are discoverable by the client through the Query
interface \ref{sec:query}.

These location paths can be part of the name-space or rendered
alongside. The following example shows how the locations paths are
rendered alongside the name-space hierarchy. This means that the
locations paths defined by \hl{Kind}s or \hl{Mixin}s are not part of
the hierarchy of the REST Resources.

\begin{verbatim}
Category: compute;
          class=kind;
          scheme=http://schemas.ogf.org/occi/infrastructure#;
          location=/compute 
    (This is an compute kind)

Category: storage;
          class=kind;
          scheme=http://schemas.ogf.org/occi/infrastructure#;
          location=/storage 
    (This is an storage kind)

Category: my_stuff;
          class=mixin;
          scheme=http://example.com/occi/my_stuff#;
          location=/my_stuff 
    (This is a mixin of user1)

The following namespace hierarchy is used in the examples:

http://example.com/-/
http://example.com/vms/user1/vm1
http://example.com/vms/user1/vm2
http://example.com/vms/user2/vm1
http://example.com/disks/user1/disk1
http://example.com/disks/user2/disk1
http://example.com/compute/
http://example.com/storage/
http://example.com/my_stuff/
\end{verbatim}

Location paths can also be part of the name-space hierarchy. In this
case the location is embedded in the hierarchy of resources (e.g. the location
of the compute \hl{Kind} is part of
http://example.com/vms/user1/vm1).

\begin{verbatim}
Category: compute;
          class=kind;
          scheme=http://schemas.ogf.org/occi/infrastructure#;
          location=/vms 
    (This is an compute kind)

Category: storage;
          class=kind;
          scheme=http://schemas.ogf.org/occi/infrastructure#;
          location=/disks 
    (This is an storage kind)

Category: my_stuff;
          class=mixin;
          scheme=http://example.com/occi/my_stuff#;
          location=/my_stuff 
    (This is a mixin of user1)

The following namespace hierarchy is used in the examples:

http://example.com/-/
http://example.com/vms/user1/vm1
http://example.com/vms/user1/vm2
http://example.com/vms/user2/vm1
http://example.com/disks/user1/disk1
http://example.com/disks/user2/disk1
http://example.com/my_stuff/
\end{verbatim}

The flat name-space defined by OCCI where each resource instance has an
identifier can be mapped to this hierarchical name-space by using the
complete URIs of an resource instance as the identifier.

\subsubsection{Various Operations and their Prerequisites and Behaviors}

\paragraph{Operations on Resource Instances}
The following operations MUST be implemented by the OCCI
implementation for operations on resource instances. The resource
instance is uniquely identified by an URI (For example:
\emph{http://example.com/vms/user1/vm1}).\footnote{The path MUST not
  end with an '/' - that would mean that a client operates on a path
  in the name-space hierarchy}

\begin{description}
\item[Creating a resource instance] A request to create a resource
  instance MUST contain at least one HTTP category rendering which is
  (or relates to) a \hl{Kind} definition. If multiple HTTP categories
  are defined the first one which is (or relates to) to a \hl{Kind}
  MUST be used for defining the type of the resource
  instance. Optional information which might be provided by the client
  and if available MUST be used are HTTP Links and HTTP
  X-OCCI-Attributes (mapping to \hl{Link} and the attributes of an
  resource instance). Two ways can be used to create a new resource
  instance - HTTP POST or PUT:
\begin{verbatim}
> POST / HTTP/1.1
> [...]
> 
> Category: compute; class=kind; scheme=http://schemas.ogf.org/occi/infrastructure#
> X-OCCI-Attribute: occi.compute.cores=2
> X-OCCI-Attribute: occi.compute.hostname=foobar
> [...]
 
< HTTP/1.1 200 OK
< [...]
< Location:http://example.com/vms/user1/vm1
\end{verbatim}
  The path on which this POST verb is executed can be any existing
  path in the hierarchy of the Service provider's name-space. The OCCI
  implementation MUST return the Location of the newly created
  resource instance.

  HTTP PUT can also be used to create a resource instance. In this
  case the client ask the service provider to create a resource
  instance at a certain path in the name-space hierarchy.\footnote{If a
    Service Provider does not want the user to define the path of a
    resource instance it can return a Bad Request return code - See
    section \ref{sec:return_codes}. Service Providers MUST ensure that
    the paths of REST resources stays unique in their name-space.}
\begin{verbatim}
> PUT /vms/user1/my_first_virtual_machine HTTP/1.1
> [...]
> 
> Category: compute; class=kind; scheme=http://schemas.ogf.org/occi/infrastructure#
> X-OCCI-Attribute: occi.compute.cores=2
> X-OCCI-Attribute: occi.compute.hostname=foobar
> [...]
 
< HTTP/1.1 200 OK
< [...]
\end{verbatim}
  The OCCI implementation will return an OK code.

\item[Retrieving a resource instance] For retrieval the HTTP GET verb
  is used. It MUST return at least the HTTP category which defines the
  \hl{Kind} of the resource instance. HTTP Links pointing to related
  resource instances, other URI or Actions MUST be included if
  present. Only Actions currently applicable SHOULD be rendered using
  HTTP Links. The Attributes of the resource instance MUST be exposed
  to the client if available.
\begin{verbatim}
> GET /vms/user1/vm1 HTTP/1.1
> [...]
 
< HTTP/1.1 200 OK
< [...]
< Category: compute; class=kind; scheme=http://schemas.ogf.org/occi/infrastructure#
< Category: my_stuff; class=mixin; scheme=http://example.com/occi/my_stuff#
< X-OCCI-Attribute: occi.compute.cores=2
< X-OCCI-Attribute: occi.compute.hostname=foobar
< Link: [...]
\end{verbatim}

\item[Updating a resource instance] Before updating a resource
  instance it is RECOMMENDED that the client first retrieves the
  resource instance. Updating is done using the HTTP PUT verb. Only
  the information (HTTP Links, HTTP X-OCCI-Attributes or HTTP
  categories), which are updated MUST be provided along with the
  request.\footnote{Changing the type of the resource instance MUST
    not be possible.}
\begin{verbatim}
> PUT /vms/user1/vm1 HTTP/1.1
> [...]
> 
> X-OCCI-Attribute: occi.compute.memory=4.0
> [...]
 
< HTTP/1.1 200 OK
< [...]
\end{verbatim}

\item[Deleting a resource instance] A resource instance can be deleted
  using the HTTP DELETE verb. No other information SHOULD be added to
  the request.\footnote{If the resource instances is a \hl{Link} type
    the source and target must be updated accordingly}
\begin{verbatim}
> DELETE /vms/user1/vm1 HTTP/1.1
> [...]

< HTTP/1.1 200 OK
< [...]
\end{verbatim}

\item[Triggering an Action on a resource instance] To trigger an
  action on a resource instance the request MUST containing the HTTP
  Category defining the \hl{Action}. It MAY include HTTP
  X-OCCI-Attributes which are the parameters of the action. Actions
  are triggered using the HTTP POST verb and by adding a query to
  the URI. This query exposes the term of the \hl{Action}. If an
  action is not available a Bad Request should be returned.
\begin{verbatim}
> POST /vms/user1/vm1?action=stop HTTP/1.1
> [...]
> Category: compute; class=action; scheme=...
> X-OCCI-Attribute: method=poweroff

< HTTP/1.1 200 OK
< [...]
\end{verbatim}
\end{description}

\paragraph{Handling the Query Interface}
\label{sec:query}
The query interface MUST be implemented by all OCCI
implementations. It MUST be found at the path \emph{/-/} off the root
of the OCCI implementation. The following operations, listed below,
MUST be implemented by the service.

\begin{description}
\item[Retrieval of all registered \hl{Kind}s and \hl{Mixin}s] The HTTP
  verb GET must be used to retrieve all l\hl{Kind}s and \hl{Mixin}s the
  service can handle. This allows the client to discover the
  capabilities of the OCCI implementation. The result MUST contain all
  information about the \hl{Kind}s and \hl{Mixin}s (including
  Attributes and \hl{Actions} assigned).
\begin{verbatim}
> GET /-/ HTTP/1.1
> [...]
 
< HTTP/1.1 200 OK
< [...]
< Category: compute;
<           class=kind;
<           scheme=http://schemas.ogf.org/occi/infrastructure#;
<           rel=http://schemas.ogf.org/occi/core\#resource;
<           attributes="occi.compute.cores occi...";
<           actions="http://schemas.ogf.org/occi/infrastructure/compute/action#stop ...";
<           location=/compute;
< Category: my_stuff;
<           class=mixin;
<           scheme=http://example.com/occi/my_stuff#;
<           location=/my_stuff;
< Category: storage; 
<           class=kind;
<           scheme=http://schemas.ogf.org/occi/infrastructure#;
<           rel=http://schemas.ogf.org/occi/core\#resource;
<           attributes="...";
<           actions="...";
<           location=/storage;
 
\end{verbatim}
An OCCI implementation MUST support a filtering mechanism. If a HTTP
Category is provided in the request the server MUST only return the
complete rendering of the requested \hl{Kind} or \hl{Mixin}.

\item[Adding a \hl{Mixin} definition] To add a \hl{Mixin} to
  the service the HTTP PUT verb MUST be used. All possible information
  for the \hl{Mixin} must be defined. At least the HTTP Category term,
  scheme and location MUST be defined. Actions and Attributes are not
  supported:
\begin{verbatim}
> PUT /-/ HTTP/1.1
> [...]
> Category: my_stuff;
>           class=mixin;
>           scheme=http://example.com/occi/my_stuff#;
>           rel=http:/example.com/occi/something_else#mixin;
>           location=/my_stuff;

< HTTP/1.1 200 OK
< [...]
\end{verbatim}
The service might reject this request if it does not allow
user-defined \hl{Mixin}s to be created. Also on name collisions of the
defined location path the service provider might reject this
operation.

\item[Removing a \hl{Mixin} definition] A user defined
  \hl{Mixin} CAN be removed (if allowed) by using the HTTP DELETE
  verb. The information about which \hl{Mixin} should be deleted MUST
  be provided in the request:
\begin{verbatim}
> DELETE /-/ HTTP/1.1
> [...]
> Category: my_stuff; class=mixin; scheme=http://example.com/occi/my_stuff#;

< HTTP/1.1 200 OK
< [...]
\end{verbatim}
\end{description}

\paragraph{Operations on \hl{Mixin}s or \hl{Kind}s}
All the following operations CAN only be be done on a location paths
provided by \hl{Kind}s and \hl{Mixin}s. It MUST end with an
\emph{/}.

\begin{description}
\item[Retrieving All Resource Instances Belonging to \hl{Mixin} or
  \hl{Kind}] The HTTP verb GET must be used to retrieve all resource
  instances. The service provider MUST return a listing containing
  all resource instances which belong to the requested \hl{Mixin} or
  \hl{Kind}:
\begin{verbatim}
> GET /compute/ HTTP/1.1
> [...]
 
< HTTP/1.1 200 OK
< [...]
< 
< X-OCCI-Location: http://example.com/vms/user1/vm1
< X-OCCI-Location: http://example.com/vms/user1/vm2
< X-OCCI-Location: http://example.com/vms/user2/vm1
\end{verbatim}
\textbf{Note:} A OCCI implementation MUST support a filtering
mechanism. If a HTTP Category is provided in the request the server
MUST only return the resource instances belonging to the provided
\hl{Kind} or \hl{Mixin}. The provided HTTP category definition SHOULD
be different from the \hl{Kind} or \hl{Mixin} definition which defined
the location path used in the request.

\item[Triggering Actions on All Instances of a \hl{Mixin} or
  \hl{Kind}] Actions can be triggered on all resource instances of the
  same \hl{Mixin} or \hl{Kind}. The HTTP POST verb MUST be used. Also
  the Action MUST be defined by the \hl{Kind} or \hl{Mixin} which
  defines the location path which is used in the request:
\begin{verbatim}
> POST /compute/?action=stop HTTP/1.1
> [...]
> X-OCCI-Attribute: method=poweroff

< HTTP/1.1 200 OK
< [...]
\end{verbatim}

\item[Associate resource instances with \hl{Mixin}s] One
  or multiple resource instances can be associated with a \hl{Mixin}
  using the HTTP PUT verb. The URIs which uniquely defined the
  resource instance MUST be provided in the request:
\begin{verbatim}
> PUT /my_stuff/ HTTP/1.1
> [...]
> X-OCCI-Location: http://example.com/vms/user1/vm1
> X-OCCI-Location: http://example.com/vms/user1/vm2
> X-OCCI-Location: http://example.com/disks/user1/disk1

< HTTP/1.1 200 OK
< [...]
\end{verbatim}

\item[Unassociated resource instance(s) from a \hl{Mixin}] One or multiple
  resource instances can be removed from a \hl{Mixin} using the HTTP
  DELETE verb. The URIs which uniquely defined the resource instance
  MUST be provided in the request:
\begin{verbatim}
> DELETE /my_stuff/ HTTP/1.1
> [...]
> X-OCCI-Location: http://example.com/vms/user1/vm1
> X-OCCI-Location: http://example.com/vms/user1/vm2
> X-OCCI-Location: http://example.com/disks/user1/disk1

< HTTP/1.1 200 OK
< [...]
\end{verbatim}
\end{description}

\paragraph{Operation on Paths in the Name-space}
The following operations are defined when operating on paths in the
name-space hierarchy which are not location paths nor resource
instances. They MUST end with \emph{/} (For example
\emph{http://example.com/vms/user1}).

\begin{description}
\item[Retrieving All resource instances Below a Path] The HTTP verb
  GET must be used to retrieve all resource instances. The service
  provider MUST return a Listing containing all resource instances
  which are children of the provided URI in the name-space hierarchy:
\begin{verbatim}
> GET /vms/user1/ HTTP/1.1
> [...]
 
< HTTP/1.1 200 OK
< [...]
< 
< X-OCCI-Location: http://example.com/vms/user1/vm1
< X-OCCI-Location: http://example.com/vms/user1/vm2
\end{verbatim}
An OCCI implementations MUST support a filtering mechanism. If a
category is provided in the request the server MUST only return the
resource instances belonging to the provided \hl{Mixin} or \hl{Kind}.

\item[Deletion of all resource instances below a path] \textbf{(Note:
  this is a potentially dangerous operation!)} The HTTP verb DELETE
  must be used to delete all resource instances under a hierarchy:
\begin{verbatim}
> DELETE /vms/user1/ HTTP/1.1
> [...]
 
< HTTP/1.1 200 OK
< [...]
\end{verbatim}
\end{description}

\subsection{Syntax and Semantics of the Rendering}
\label{sec:syntax}
All data transferred using the \textit{text/occi} and \textit{text/plain}
content types is encoded with HTTP \cite{rfc2616} compliant headers. Four
specific HTTP headers are used:
\begin{itemize}
\item Category
\item Link
\item X-OCCI-Attribute
\item X-OCCI-Location
\end{itemize}
The \textit{text/occi} content type renders these headers as true HTTP headers
in the header portion of a HTTP request or response. The \textit{text/plain}
content type renders the same headers, with identical syntax, in the body of
the HTTP request/response. See section \ref{sec:content_type} for more
information on the use of different content types.

Multiple HTTP header values MUST be supported as defined by RFC~2616
\cite{rfc2616}. This applies to both the \textit{text/occi} and
\textit{text/plain} content types. RFC 2616 defines two different methods
to render multiple header values, either a comma-separated list or multiple
header lines. The following two rendering examples are identical and both formats
MUST be supported by both OCCI client and server to be compliant.

Comma-separated rendering of multiple HTTP header values:
\begin{verbatim}
X-OCCI-Attribute: occi.compute.memory=2.0, occi.compute.speed=2.33
X-OCCI-Location: /compute/123, /compute/456
\end{verbatim}
%
Separate header lines for each HTTP header value:
\begin{verbatim}
X-OCCI-Attribute: occi.compute.memory=2.0
X-OCCI-Attribute: occi.compute.speed=2.33
X-OCCI-Location: /compute/123
X-OCCI-Location: /compute/456
\end{verbatim}

\subsubsection{Rendering of the OCCI Category, Kind and Mixin types}
Instances of the \hl{Category}, \hl{Kind} and \hl{Mixin} types \cite{occi:core}
MUST be rendered using the Category header as defined by the Web Categories
specification%
\footnote{http://tools.ietf.org/html/draft-johnston-http-category-header-01}.
%
The following syntax applies:

\begin{verbatim}
Category           = "Category" ":" #category-value
  category-value   = term
                    ";" "scheme" "=" <"> scheme <">
                    ";" "class" "=" ( class | <"> class <"> )
                    *( ";" category-param )
  category-param   = ( ( "title" "=" quoted-string )
                   | ( "rel" "=" <"> resource-type <"> )
                   | ( "location" "=" URI )
                   | ( "attributes" "=" <"> attribute-list <"> )
                   | ( "actions" "=" <"> action-list <"> ) )
  term             = token
  scheme           = URI
  type-identifier  = scheme term
  resource-type    = type-identifier *( 1*SP type-identifier )
  class            = "action" | "mixin" | "kind"
  attribute-list   = attribute-name
                   | attribute-name *( 1*SP attribute-name)
  attribute-name   = attr-component *( "." attr-component )
  attr-component   = LOALPHA *( LOALPHA | DIGIT | "-" | "_" )
  action-list      = action 
                   | action *( 1*SP action)
  action           = type-identifier
\end{verbatim}

The following example illustrates the rendering of the \hl{Kind} instance
assigned to the \hl{Storage} type \cite{occi:infrastructure}:
\begin{verbatim}
Category: storage;
    scheme="http://schemas.ogf.org/occi/infrastructure\#";
    class=kind;
    title="Storage Resource";
    rel="http://schemas.ogf.org/occi/core\#resource";
    attributes="occi.storage.size occi.storage.state";
    actions="http://schemas.ogf.org/occi/infrastructure/storage/action\#resize ...";
\end{verbatim}

\subsubsection{Rendering of OCCI Link instance references}
The rendering of a \hl{Resource} instance \cite{occi:core}
MUST represent any associated \hl{Link} instances using the HTTP Link
header specified in the Web Linking RFC 5988 \cite{rfc5988}.  For
example, rendering of a \hl{Compute} instance linked to a \hl{Storage}
instance MUST include a Link header displaying the \hl{Link} instance
of the relation.

The following syntax MUST be used to represent OCCI \hl{Link} type
instance references:

\begin{verbatim}
Link               = "Link" ":" #link-value
  link-value       = "<" URI-Reference ">"
                    ";" "rel" "=" <"> resource-type <">
                    ";" "self" "=" <"> link-instance <">
                    *( ";" link-param )
  link-param       = ( ( "category" "=" link-type )
                   | ( link-attribute ) )
  term             = token
  scheme           = URI
  type-identifier  = scheme term
  resource-type    = type-identifier *( 1*SP type-identifier )
  link-type        = type-identifier *( 1*SP type-identifier )
  link-instance    = URI-reference
  link-attribute   = attribute-name "=" ( token | quoted-string )
  attribute-name   = attr-component *( "." attr-component )
  attr-component   = LOALPHA *( LOALPHA | DIGIT | "-" | "_" )
\end{verbatim}

The following example illustrates the rendering of a \hl{NetworkInterface}
\cite{occi:infrastructure} instance linking to a \hl{Network} resource
instance:
\begin{verbatim}
Link: </network/123>;
    rel="http://schemas.ogf.org/occi/infrastructure\#network";
    self="/link/networkinterface/456";
    category="http://schemas.ogf.org/occi/infrastructure\#networkinterface";
    occi.networkinterface.interface="eth0";
    occi.networkinterface.mac="00:11:22:33:44:55";
    occi.networkinterface.state="active";
\end{verbatim}

\subsubsection{Rendering of references to OCCI Action instances}
The rendering of a \hl{Resource} instance \cite{occi:core}
MUST represent any associated \hl{Action} instances using the HTTP Link
header specified in the Web Linking RFC 5988 \cite{rfc5988}.  For
example, rendering of a \hl{Compute} instance MUST include a Link header
displaying any \hl{Action}s currently applicable to the resource instance.

The following syntax MUST be used to represent OCCI \hl{Action} instance
references:

\begin{verbatim}
Link               = "Link" ":" #link-value
  link-value       = "<" action-uri ">"
                    ";" "rel" "=" <"> action-type <">
  term             = token
  scheme           = URI
  type-identifier  = scheme term
  action-type      = type-identifier
  action-uri       = URL "?" "action=" term
\end{verbatim}

The following example illustrates the rendering of a reference to the ``start''
\hl{Action} defined for the \hl{Compute} type \cite{occi:infrastructure}. Such
a reference would be present in the rendering of a \hl{Compute} instance.
\begin{verbatim}
Link: </compute/123?action=start>;
    rel="http://schemas.ogf.org/occi/infrastructure/compute/action#start"
\end{verbatim}

\subsubsection{Rendering of OCCI-Attributes}
The X-OCCI-Attribute MUST be used to render the attributes associated
with a OCCI Kind. A simple key-value format is used. The field value
consist of an attribute name followed by an equal sign ("=") and the
attribute value. The attribute value must be double quoted if it
includes a separator character, see RFC 2616 (page 16).

\begin{verbatim}
Attribute     = "X-OCCI-Attribute" ":" attribute-value
  attribute-value = token [ "=" ( token | quoted-string ) ]
\end{verbatim}

Valid attribute names for OCCI Kinds are specified in appropriate
Extension documents \ref{occi:infrastructure}.

\subsubsection{Rendering of Location-URLs}
To render an OCCI representation solely in the header, the
X-OCCI-Location HTTP header MUST be used to return a list of Kind
URLs. Each header field value correspond to a single URL. Multiple
Kind URLs are returned using multiple X-OCCI-Location headers. See RFC
2616 for information on how to render multiple HTTP headers.

\begin{verbatim}
Location      = "X-OCCI-Location" ":" location-value
  location-value  = "<" URI ">" *("," URI)
\end{verbatim}

\subsection{General HTTP Behaviors Adopted by OCCI}
The following sections deal with some general HTTP features which are
adopted by OCCI.

\subsubsection{Security and Authentication}
OCCI does not require that an authentication mechanism be used nor
does it require that client to service communications are secured. It
does recommend that an authentication mechanism be used and that where
appropriate, communications are encrypted using HTTP over TLS. The
authentication mechanisms that CAN be used with OCCI are those that
can be used with HTTP and TLS.

\subsubsection{Caching Headers}
The responses from an OCCI implementation CAN include headers with
strict Caching purposes like E-Tags.

\subsubsection{Versioning}
Information about what version of OCCI is supported by a OCCI
implementation MUST be advertised to a client on each response to a
client. The version field in the response MUST include the value
OCCI/X.Y, where X is the major version number and Y is the minor
version number of the implemented OCCI specification. In the case of a
HTTP Header Rendering, the server response MUST relay versioning
information using the HTTP header name 'Server'.

\begin{verbatim}
HTTP/1.1 202 Accepted
Server: occi-server/1.1 (linux) OCCI/1.1
[...]
\end{verbatim}

Complimenting the service-side behavior of an OCCI implementation, a
client SHOULD indicate to the OCCI service implementation the version
it expects to interact with. For the clients, the information SHOULD
be advertised in all requests it issues. A client request SHOULD
relay versioning information in the 'User-Agent' header. The
'User-Agent' field MUST include the same value (OCCI/X.Y) as supported
by the Server HTTP header.

\begin{verbatim}
GET <Path> HTTP/1.1
Host: example.com
User-Agent: occi-client/1.1 (linux) libcurl/7.19.4 OCCI/1.1
[...]
\end{verbatim}

If a OCCI implementation receives a request from a client that
supplies a version number higher than the service supports, the
service MUST respond back to the client with an exception indicating
that the requested version is not implemented. Where a client
implements OCCI using a HTTP transport, the HTTP code 501, not
implemented, MUST be used.

OCCI implementations which implement this version of the Document MUST
use the version String \emph{OCCI/1.1}.

\subsubsection{Content-type and Accept headers}
\label{sec:content_type}
A server MUST react according to the Accept header the client
provides. If none is given - or \textit{*/*} is used - the service MUST
use the Content-type \emph{text/plain}. This is the fall-back
rendering and MUST be implemented. Otherwise the according rendering
MUST be used. Each Rendering SHOULD expose which Accept and
Content-type header fields it can handle. Overall the service MUST
support the \textit{text/occi} and \textit{text/plain} Content-types.

The server MUST also return the proper Content-type header. If a
client provides information with a Content-Type - the information MUST
be parsed accordingly.

When the Client request a Content-Type that will result in an
incomplete or faulty rendering the Service MUST return the unsupported
media type , 415, HTTP code.

The following examples demonstrate the behavior of an HTTP GET
operations on the resource instance \emph{} using two different HTTP
Accept headers:

\begin{verbatim}
> GET /vms/user1/vm1 HTTP/1.1
> Accept: text/plain
> [...]
 
< HTTP/1.1 200 OK
< [...]
< Category: compute; class=kind; scheme=http://schemas.ogf.org/occi/infrastructure#
< Category: my_stuff; class=mixin; scheme=http://example.com/occi/my_stuff#
< X-OCCI-Attribute: occi.compute.cores=2
< X-OCCI-Attribute: occi.compute.hostname=foobar
< Link: [...]
\end{verbatim}

And with \emph{text/occi} as HTTP Accept header:

\begin{verbatim}
> GET /vms/user1/vm1 HTTP/1.1
> Accept: text/occi
> [...]
 
< HTTP/1.1 200 OK
< Category: compute; class=kind; scheme=http://schemas.ogf.org/occi/infrastructure#,
            my_stuff; class=mixin; scheme=http://example.com/occi/my_stuff#
< X-OCCI-Attribute: occi.compute.cores=2, occi.compute.hostname=foobar
< Link: [...]
< [...]
OK
\end{verbatim}

\paragraph{The Content-type text/plain}
While using this rendering with the Content-Type \textit{text/plain}
the information described in section \ref{sec:syntax} MUST be placed
in the HTTP Body.

Each rendering of an OCCI base type will be placed in the body. Each
entry consists of a name followed by a colon (":") and the field
value. The format of the field value is specified separately for each
of the three header fields, see section \ref{sec:syntax}.

\paragraph{The Content-type text/occi}
While using this rendering with the Content-Type \textit{text/occi}
the information described in section \ref{sec:syntax} MUST be placed
in the HTTP Header. The body MUST contain the string 'OK' on
successful operations.

The HTTP header fields MUST follow the specification in RFC 2616
\cite{rfc2616}. A header field consists of a name followed by a colon
(":") and the field value. The format of the field value is specified
separately for each of the header fields, see section
\ref{sec:syntax}.

\textbf{Limitations: } HTTP header fields MAY appear multiple times in
a HTTP request or response. In order to be OCCI compliant the
specification of multiple message-header fields according to RFC 2616
MUST be fully supported. In essence there are two valid representation
of multiple HTTP header field values. A header field might either
appear several times or as a single header field with a
comma-separated list of field values. Due to implementation issues in
many web frameworks and client libraries it is RECOMMENDED to use the
comma-separated list format for best interoperability.

HTTP header field values which contain separator characters MUST be
properly quoted according to RFC 2616.

Space in the HTTP header section of a HTTP request is a limited
resource. By this, it is noted that many HTTP servers limit the number
of bytes that can be placed in the HTTP Header area. Implementers MUST
be aware of this limitation in their own implementation and take
appropriate measures so that truncation of header data does NOT
occur.

\paragraph{The Content-type text/uri-list}
This Rendering can handle the \textit{text/uri-list} Accept Header. It
will use the Content-type \textit{text/uri-list}.

This rendering cannot render resource instances or \hl{Kind}s or
\hl{Mixin}s directly but just links to them. For concrete rendering of
Kinds and Categories the Content-types \textit{text/occi},
\textit{text/plain} MUST be used. If a request is done with the
\textit{text/uri-list} in the Accept header, while not requesting for
a Listing a Bad Request MUST be returned.

\subsubsection{Return codes}
\label{sec:return_codes}
At any point the service provider CAN return any of the following HTTP
Return Codes:

\mytablefloat{\label{tbl:http_codes}HTTP Return Codes}{
\begin{tabular}{l|l|p{3in}}
\toprule
Code & Description & Notes \\
\colrule
200 & OK & \\
202 & Accepted & Used for asynchronous non-blocking calls. \\
400 & Bad Request & For example on parsing errors or missing information \\
401 & Unauthorized & \\
403 & Forbidden & \\
405 & Method Not Allowed & \\
409 & Conflict & \\
410 & Gone & \\
415 & Unsupported Media Type & \\
500 & Internal Server Error & \\
501 & Not Implemented & \\
503 & Service Unavailable & \\
\botrule
\end{tabular}}

\subsection{More complete examples}
Since most examples are not complete due to space limitations this
section will give some more complete examples.

\subsubsection{Creating a resource instance}
\begin{verbatim}
> POST / HTTP/1.1
> User-Agent: curl/7.21.0 (x86_64-pc-linux-gnu) libcurl/7.21.0 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18
> Host: localhost:8080
> Accept: */*
> Cookie: pyocci_user=Zm9v|1291753962|7011a4821179ff98ea96d4b44fade0512b1ffc52
> Content-Type: text/occi
> Category: compute;class=kind;scheme=http://schemas.ogf.org/occi/infrastructure#
> 
< HTTP/1.1 200 OK
< Content-Length: 2
< Content-Type: text/html; charset=UTF-8
< Location: /users/foo/compute/b9ff813e-fee5-4a9d-b839-673f39746096
< Server: pyocci OCCI/1.1
< 
* Connection #0 to host localhost left intact
* Closing connection #0
OK% 
\end{verbatim}

\subsubsection{Retrieving a resource instance}
\begin{verbatim}
> GET /users/foo/compute/b9ff813e-fee5-4a9d-b839-673f39746096 HTTP/1.1
> User-Agent: curl/7.21.0 (x86_64-pc-linux-gnu) libcurl/7.21.0 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18
> Host: localhost:8080
> Accept: */*
> Cookie: pyocci_user=Zm9v|1291753962|7011a4821179ff98ea96d4b44fade0512b1ffc52
> 
< HTTP/1.1 200 OK
< Content-Length: 415
< Etag: "ef485dc7066745cb0fe1e31ecdd4895c356b5bd5"
< Content-Type: text/plain
< Server: pyocci OCCI/1.1
< 
Category: compute;class=kind;scheme=http://schemas.ogf.org/occi/infrastructure#
Link: </users/foo/compute/b9ff813e-fee5-4a9d-b839-673f39746096?action=start>
X-OCCI-Attribute: occi.compute.architecture=x86
X-OCCI-Attribute: occi.compute.state=inactive
X-OCCI-Attribute: occi.compute.speed=1
X-OCCI-Attribute: occi.compute.memory=2
X-OCCI-Attribute: occi.compute.cores=2
X-OCCI-Attribute: occi.compute.hostname=dummy
\end{verbatim}

\section{Contributors}
\input{include/contributors}

\section{Glossary}
\label{sec:glossary}
\input{include/glossary}

\section{Intellectual Property Statement}
\input{include/ip}

\section{Disclaimer}
\input{include/disclaimer}

\section{Full Copyright Notice}
\input{include/copyright}

\section{References}

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
